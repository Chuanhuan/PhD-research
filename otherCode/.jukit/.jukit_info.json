{"cmd": "import numpy as np\n\n\ndef fft(x):\n    \"\"\"\n    Compute the Fast Fourier Transform (FFT) of a 1D array x.\n\n    Parameters:\n    x (np.array): The input array (1D complex array).\n\n    Returns:\n    np.array: The FFT of the input array.\n    \"\"\"\n    N = len(x)\n    if N <= 1:\n        return x\n\n    # Divide the array into even and odd parts\n    even = fft(x[0::2])\n    odd = fft(x[1::2])\n\n    # Compute the combined terms using the twiddle factor\n    T = np.exp(-2j * np.pi * np.arange(N) / N)[: N // 2] * odd\n    return np.concatenate([even + T, even - T])\n\n\ndef ifft(X):\n    \"\"\"\n    Compute the Inverse Fast Fourier Transform (IFFT) of a 1D array X.\n\n    Parameters:\n    X (np.array): The input array in frequency domain (1D complex array).\n\n    Returns:\n    np.array: The IFFT of the input array (time domain).\n    \"\"\"\n    N = len(X)\n    if N <= 1:\n        return X\n\n    # Apply conjugate, FFT, and scale by 1/N\n    X_conj = np.conjugate(X)\n    X_fft = fft(X_conj)\n    return np.conjugate(X_fft) / N\n\n\n# Example usage:\n# Create a sample signal of 8 points\n# x = np.random.random(8)  # Input signal (real values)\nx = np.array([1, 2, 3, 4, 5, 6, 0, 0])\nx_fft = fft(x)  # \nx_ifft = ifft(x_fft)  # IFFT (reconstructed signal)\n\nprint(\"Input signal:\", x)\nprint(\"FFT:\", x_fft)\nprint(\"Reconstructed signal (IFFT):\", x_ifft)", "cmd_opts": " --cell_id=NONE -s", "import_complete": 1, "terminal": "kitty"}