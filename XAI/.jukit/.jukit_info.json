{"cmd": "\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom sklearn.manifold import TSNE\n\n\ndef visualize_results(test_loader, model, c_vae, critic, device):\n    # Get test batch\n    data, labels = next(iter(test_loader))\n    data = data.to(device)\n\n    with torch.no_grad():\n        # Get model outputs\n        x = model(data)\n        output = c_vae(x)\n        c = critic(x)\n\n        # Convert to numpy arrays\n        # Using \"recon\" or \"z_mean\" as your reconstructed image depends on your architecture.\n        # Here we follow your original code:\n        recon_imgs = output[\"z_mean\"].cpu().numpy()\n        true_imgs = data.cpu().numpy()\n        # Reshape critic output to (batch, 28*28) then later to (28,28)\n        c_values = c.cpu().numpy().reshape(-1, 28 * 28)\n        labels = labels.cpu().numpy()\n\n    # Create figure\n    plt.figure(figsize=(12, 8))\n\n    # Plot a grid of 3x3 images with the critic heatmap overlay\n    for idx in range(9):\n        ax = plt.subplot(3, 3, idx + 1)\n        # Show the reconstructed image (grayscale)\n        plt.imshow(recon_imgs[idx].reshape(28, 28), cmap=\"gray\")\n        # Overlay the critic's output as a heatmap (using 'jet' colormap)\n        plt.imshow(c_values[idx].reshape(28, 28), cmap=\"jet\", alpha=0.5)\n        plt.colorbar()\n        plt.title(f\"Label: {labels[idx]}\", fontsize=8)\n        plt.axis(\"off\")\n\n    plt.tight_layout()\n    plt.savefig(\"reconstructed_images.png\")\n    plt.show()\n\n\n# Usage\nmodel.eval()\nc_vae.eval()\ncritic.eval()\nvisualize_results(test_loader, model, c_vae, critic, Config.device)", "cmd_opts": " --cell_id=Pv1qVZYTpt -s", "import_complete": 1, "terminal": "tmux"}