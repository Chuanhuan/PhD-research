{"cmd": "\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom sklearn.manifold import TSNE\n\n\ndef visualize_results(test_loader, model, c_vae, critic, device):\n    # Get test batch\n    data, labels = next(iter(test_loader))\n    data = data.to(device)\n\n    with torch.no_grad():\n        # Get model outputs\n        x = model(data)\n        output = c_vae(x)\n        c = critic(x)\n\n        # Convert to numpy arrays\n        # Using \"recon\" or \"z_mean\" as your reconstructed image depends on your architecture.\n        # Here we follow your original code:\n        recon_imgs = output[\"z_mean\"].cpu().numpy()\n        true_imgs = data.cpu().numpy()\n        # Reshape critic output to (batch, 28*28) then later to (28,28)\n        c_values = c.cpu().numpy().reshape(-1, 28 * 28)\n        labels = labels.cpu().numpy()\n\n    # Create figure\n    plt.figure(figsize=(12, 8))\n\n    # Plot a grid of 3x3 images with the critic heatmap overlay\n    for idx in range(9):\n        ax = plt.subplot(3, 3, idx + 1)\n        # Show the reconstructed image (grayscale)\n        plt.imshow(recon_imgs[idx].reshape(28, 28), cmap=\"gray\")\n        # Overlay the critic's output as a heatmap (using 'jet' colormap)\n        plt.imshow(c_values[idx].reshape(28, 28), cmap=\"jet\", alpha=0.5)\n        plt.colorbar()\n        plt.title(f\"True Label: {labels[idx]}\", fontsize=8)\n        plt.axis(\"off\")\n\n    plt.tight_layout()\n    plt.savefig(\"reconstructed_images.png\")\n    plt.show()\n\n\ndef visualize_comparison_results(test_loader, model, c_vae, critic, device):\n    # Get test batch\n    data, labels = next(iter(test_loader))\n    data = data.to(device)\n\n    with torch.no_grad():\n        # Get model outputs\n        x = model(data)\n        output = c_vae(x)\n        c = critic(x)\n        _, pred_z = model(output[\"z_mean\"]).max(1)\n\n        # Convert to numpy arrays\n        recon_imgs = output[\"z_mean\"].cpu().numpy()\n        true_imgs = data.cpu().numpy()\n        # Ensure critic output has shape (batch, 28, 28)\n        c_values = c.cpu().numpy().reshape(-1, 28, 28)\n        labels = labels.cpu().numpy()\n\n    # Create figure with a grid of 3 rows x 9 columns\n    plt.figure(figsize=(18, 6))\n    \n    num_samples = 9  # number of samples to display\n\n    for idx in range(num_samples):\n        # True image in row 1\n        ax1 = plt.subplot(3, num_samples, idx + 1)\n        plt.imshow(true_imgs[idx].reshape(28, 28), cmap=\"gray\")\n        plt.title(f\"True: {labels[idx]}\", fontsize=8)\n        plt.axis(\"off\")\n        \n        # Reconstructed image in row 2\n        ax2 = plt.subplot(3, num_samples, idx + 1 + num_samples)\n        plt.imshow(recon_imgs[idx].reshape(28, 28), cmap=\"gray\")\n        plt.title(f\"Reconstructed Prediction = {pred_z[idx]}\", fontsize=8)\n        plt.axis(\"off\")\n        \n        # Critic heatmap in row 3\n        ax3 = plt.subplot(3, num_samples, idx + 1 + 2*num_samples)\n        im = plt.imshow(c_values[idx].reshape(28, 28), cmap=\"jet\", alpha=0.5)\n        plt.title(\"Critic Heatmap\", fontsize=8)\n        plt.axis(\"off\")\n        plt.colorbar(im, ax=ax3, fraction=0.046, pad=0.04)\n\n    plt.tight_layout()\n    plt.savefig(\"comparison_images.png\")\n    plt.show()\n# Usage\nmodel.eval()\nc_vae.eval()\ncritic.eval()\nvisualize_results(train_loader, model, c_vae, critic, Config.device)\nvisualize_comparison_results(train_loader, model, c_vae, critic, Config.device)", "cmd_opts": " --cell_id=Pv1qVZYTpt -s", "import_complete": 1, "terminal": "tmux"}